use arx::{ExtractBuilder, FileFilter};
use clap::{Parser, ValueHint};
use log::info;
use std::env::current_dir;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;

const AFTER_LONG_HELP: &str = color_print::cstr!("
<s,u>Files to extract</>

By default, arx extract the whole archive.
You can specify what to extract either by:
- Simple values given as [EXTRACT_FILES].
- File list given with <s>--file-list</> option.

Both are equivalent. The former is usefull if you have too many entry to extract to pass it as
cmdline options or if the list is generated by a script.

The items given in the extract list can be :
- A file: It is extracted.
- A directory: It is extracted. If recurse options is set (the default), its content is also extracted.
- A link: A symlink is created.

<s,u>Filter</>

You can set a blob filter using <s>--glob</> option.
Glob filter is only used to filter content under a given directory. Entries given in extract list are
always extracted. If you don't give a extract list, filter is applied to the whole archive.

- <K!>?</> matches any single character.
- <K!>*</> matches any (possibly empty) sequence of characters.
- <K!>**</> matches the current directory and arbitrary subdirectories. This sequence must form a single path component, so both <K!>**a</> and <K!>b**</> are invalid and will result in an error. A sequence of more than two consecutive <K!>*</> characters is also invalid.
- <K!>[...]</> matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode, so e.g. <K!>[0-9]</> specifies any character between 0 and 9 inclusive. An unclosed bracket is invalid.
- <K!>[!...]</> is the negation of <K!>[...]</>, i.e. it matches any characters not in the brackets.
- The metacharacters <K!>?</>, <K!>*</>, <K!>[</>, <K!>]</> can be matched by using brackets (e.g. <K!>[?]</>). When a <K!>]</> occurs immediately following <K!>[</> or <K!>[!</> then it is interpreted as being part of, rather then ending, the character set, so <K!>]</> and NOT <K!>]</> can be matched by <K!>[]]</> and <K!>[!]]</> respectively. The <K!>-</> character can be specified inside a character sequence pattern by placing it at the start or the end, e.g. <K!>[abc-]</>.

This filter is not recursive. If you want to extract all file under a directory foo, use <K!>foo/**/*</>
Filter is relative to root directory.

<s,u>Recursive</>

The recurse flag tell how to interpret the extract files given as input (either with EXTRACT_FILESâ€¯or FILE_LIST)

If recurse is true (default), the filter is recursive :
If you give a directory, all files/subdirctory in the given directory will also be extracted.
You don't need to list files under the directory (but listing them will not be an error).

If recurse is false, the filter is not recursive :
If you give a directory, only the directory is created (empty).
If you want to extract files under the directory, you must also list them.
It is not an error to not give the parent directory (arx create parent directory for you).

<s,u>Root Directory</>

By default, arx extracts from the root directory of the archive.
<s>--root-dir</> option allow to change the root directory.
This is equivalent to a (virtual) cd in the root directory before walking the tree and apply filter.
Extract list and filter are relative to the root filter.
");

/// Extract the content of an archive
#[derive(Parser, Debug)]
#[command(after_long_help=AFTER_LONG_HELP)]
pub struct Options {
    /// Archive to read
    #[arg(value_hint=ValueHint::FilePath)]
    infile: PathBuf,

    /// Directory in which extract the archive. (Default to current directory)
    #[arg(short = 'C', required = false, value_hint=ValueHint::DirPath)]
    outdir: Option<PathBuf>,

    /// Files to extract
    #[arg(group = "input", value_hint=ValueHint::AnyPath)]
    extract_files: Vec<arx::PathBuf>,

    /// Root directory
    #[arg(long)]
    root_dir: Option<PathBuf>,

    /// Print a progress bar of the extraction
    #[arg(short = 'p', long = "progress", default_value_t = false, action)]
    progress: bool,

    /// Get the list of files/directories to extract from the FILE_LIST (incompatible with EXTRACT_FILES)
    #[arg(
        short = 'L',
        long = "file-list",
        group = "input",
        value_hint = ValueHint::FilePath
    )]
    file_list: Option<PathBuf>,

    /// Use a glob pattern to filter file to extract
    #[arg(short = 'g', long, group = "input")]
    glob: Option<String>,

    #[arg(from_global)]
    verbose: u8,

    /// How to overwrite existing files
    ///
    /// Available options are:
    /// - error: Do not extract the entry if a file already exists and stop the
    ///   extraction with an error code.
    /// - warn (default): Do not extract the entry if a file already exists but print
    ///   a warning.
    /// - skip: Do not extract the entry if a file already exists
    /// - newer: Overwrite existing file if entry in the archive is newer than existing one.
    /// - overwrite: Alway overwrite existing file.
    #[arg(long, default_value = "warn")]
    overwrite: arx::Overwrite,

    /// Recursively extract directories
    ///
    /// Default value is true.
    #[arg(
        short,
        long,
        required = false,
        default_value_t = true,
        default_value_ifs([
            ("no_recurse", clap::builder::ArgPredicate::IsPresent, "false"),
        ]),
        conflicts_with = "no_recurse",
        action
    )]
    recurse: bool,

    /// Force `--recurse` to be false.
    #[arg(long)]
    no_recurse: bool,
}

fn get_extract_list(options: &Options) -> anyhow::Result<Vec<arx::PathBuf>> {
    if let Some(file_list) = &options.file_list {
        let file = File::open(file_list)?;
        let mut extract_files: Vec<arx::PathBuf> = Vec::new();
        for line in BufReader::new(file).lines() {
            extract_files.push(line?.into());
        }
        Ok(extract_files)
    } else {
        Ok(options.extract_files.clone())
    }
}

fn get_extract_filter(options: &Options) -> anyhow::Result<Box<dyn FileFilter>> {
    if let Some(pattern) = &options.glob {
        Ok(Box::new(PatternFilter(glob::Pattern::new(pattern)?)))
    } else {
        Ok(Box::new(()))
    }
}

struct PatternFilter(pub glob::Pattern);

impl arx::FileFilter for PatternFilter {
    fn accept(&self, path: &arx::Path) -> bool {
        const MATCH_OPTIONS: glob::MatchOptions = glob::MatchOptions {
            case_sensitive: true,
            require_literal_separator: true,
            require_literal_leading_dot: false,
        };
        self.0.matches_with(path.as_str(), MATCH_OPTIONS)
    }

    fn early_exit(&self) -> bool {
        false
    }
}

pub fn extract(options: Options) -> anyhow::Result<()> {
    let extract_list = get_extract_list(&options)?;
    let filter = get_extract_filter(&options)?;
    let outdir = match options.outdir {
        Some(o) => o,
        None => current_dir()?,
    };

    let arx = arx::Arx::new(&options.infile)?;
    info!("Extract archive {:?} in {:?}", &options.infile, outdir);

    let builder = ExtractBuilder::new(&outdir)
        .items(&extract_list, options.recurse)
        .filter(filter)
        .progress(options.progress)
        .overwrite(options.overwrite);

    Ok(builder.extract(
        &arx,
        options
            .root_dir
            .as_ref()
            .map(arx::Path::from_path)
            .transpose()?,
    )?)
}
